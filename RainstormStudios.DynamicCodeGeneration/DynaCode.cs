//  Copyright (c) 2008, Michael unfried
//  Email:  serbius3@gmail.com
//  All rights reserved.

//  Redistribution and use in source and binary forms, with or without modification, 
//  are permitted provided that the following conditions are met:

//  Redistributions of source code must retain the above copyright notice, 
//  this list of conditions and the following disclaimer. 
//  Redistributions in binary form must reproduce the above copyright notice, 
//  this list of conditions and the following disclaimer in the documentation 
//  and/or other materials provided with the distribution. 

//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE. IT CAN BE DISTRIBUTED FREE OF CHARGE AS LONG AS THIS HEADER 
//  REMAINS UNCHANGED.
using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.CodeDom;
using System.CodeDom.Compiler;
using Microsoft.CSharp;
using Microsoft.VisualBasic;
using Microsoft.JScript;
using Microsoft.Win32;

namespace RainstormStudios.DynamicCodeGeneration
{
    public class DynaCode
    {
        #region Global Objects
        //***********************************************************************
        // Global Variables
        // 
        private CodeDomProvider provider = null;
        private CodeCompileUnit compileUnit = new CodeCompileUnit();
        private CodeNamespace nsMain;
        private FileInfo fiSrc;
        private FileInfo fiExe;
        //***************************************************************************
        // Public Fields
        // 
        /// <summary>
        /// Gets the CodeDomeProvider contained within this AosDynaCode object.
        /// </summary>
        public CodeDomProvider CodeProvider
        {
            get { return provider; }
        }
        /// <summary>
        /// Gets a FileInfo object referencing the last source code file generated by this AosDynaCode object.
        /// </summary>
        public FileInfo SourceFile
        {
            get { return fiSrc; }
        }
        /// <summary>
        /// Gets a FileInfo object referencing the last assembly (exe or dll) file generated by this AosDynaCode object.
        /// </summary>
        public FileInfo AssemblyFile
        {
            get { return fiExe; }
        }
        #endregion

        #region Class Constructors
        //***************************************************************************
        // Class Constructors
        // 
        /// <summary>
        /// Provides a simple container and methods for building a CodeDOM-based application.
        /// </summary>
        /// <param name="ProviderType">A value of type CodeDomProviderType indicating the type of code provider to use to generate code within this AosDynaCode object.</param>
        /// <param name="NameSpace">A string value indicating the namespace to use when generating code for this AosDynaCode object.</param>
        public DynaCode(CodeDomProviderType ProviderType, string NameSpace)
        {
            provider = GetProvider(ProviderType);
            nsMain = new CodeNamespace(NameSpace);
            compileUnit.Namespaces.Add(nsMain);
            nsMain.Imports.Add(new CodeNamespaceImport("System"));
        }
        #endregion

        #region Static Methods
        //***************************************************************************
        // Static Methods
        // 
        /// <summary>
        /// Compiles the given source code file into an exe assembly or class library and saves it to the given file name.
        /// </summary>
        /// <param name="srcFile">A string value indicating the source file to compile from.</param>
        /// <param name="exeFile">A string value indicating the assembly to to create.</param>
        /// <param name="Provider">An object of type CodeDomProvider that can be used to compile the code.</param>
        /// <param name="createExe">A bool value indicating whether the CodeProvider should compile an exe file or class library.</param>
        /// <param name="includeDebugInfo">A bool value indicating whether or not to include debug information.</param>
        /// <returns>A CompilerResults object indicating the results of the compile operation.</returns>
        public static CompilerResults CompileCode(string srcFile, string exeFile, CodeDomProvider Provider, bool createExe, bool includeDebugInfo)
        {
            string[] srcs = new string[] { srcFile };
            return CompileCode(srcs, exeFile, Provider, createExe, includeDebugInfo);
        }
        /// <summary>
        /// Compiles the given source code file into an exe assembly or class library and saves it to the given file name.
        /// </summary>
        /// <param name="srcFile">A string value indicating the source file to compile from.</param>
        /// <param name="exeFile">A string value indicating the assembly to to create.</param>
        /// <param name="Provider">An object of type CodeDomProvider that can be used to compile the code.</param>
        /// <param name="createExe">A bool value indicating whether the CodeProvider should compile an exe file or class library.</param>
        /// <param name="includeDebugInfo">A bool value indicating whether or not to include debug information.</param>
        /// <returns>A CompilerResults object indicating the results of the compile operation.</returns>
        public static CompilerResults CompileCode(string[] srcFile, string exeFile, CodeDomProvider Provider, bool createExe, bool includeDebugInfo)
        {
            foreach (string file in srcFile)
            {
                if (!File.Exists(file))
                    throw new Exception("One or more source files could not be found.");
            }

            // Link the 'system.dll' file to the executable
            string[] refAsm ={ "System.dll" };
            CompilerParameters cp = new CompilerParameters(refAsm, exeFile, false);

            // Tell the Compiler whether or not we're building an exe or class library.
            cp.GenerateExecutable = createExe;

            // Start the compiler.
            CompilerResults cr = Provider.CompileAssemblyFromFile(cp, srcFile);

            // Return the results of the compilation.
            return cr;
        }
        /// <summary>
        /// Parses the given CodeDomProviderType value, creates, and returns an CodeDomProvider object used to generate and compile code.
        /// </summary>
        /// <param name="pType">A value of type CodeDomProviderType which indicates which type of CodeDomProvider to create.</param>
        /// <returns>A CodeDomProvider object.</returns>
        public static CodeDomProvider GetProvider(CodeDomProviderType pType)
        {
            switch ((int)pType)
            {
                case 0:
                    return new CSharpCodeProvider();
                case 1:
                    return new VBCodeProvider();
                case 2:
                    return new JScriptCodeProvider();
                default:
                    return new CSharpCodeProvider();
            }
        }
        /// <summary>
        /// Parses a given scope string and returns a MemberAttributes value.
        /// </summary>
        /// <param name="Scope">A string value indicating the scope text to parse.</param>
        /// <returns>A bool value indicating success or failure.</returns>
        public static MemberAttributes GetScope(string Scope)
        {
            MemberAttributes ma = new MemberAttributes();

            if (Scope.ToLower().IndexOf("abstract") > -1)
                ma |= MemberAttributes.Abstract;
            if (Scope.ToLower().IndexOf("const") > -1)
                ma |= MemberAttributes.Const;
            if ((Scope.ToLower().IndexOf("sealed") > -1) || Scope.ToLower().IndexOf("final") > -1)
                ma |= MemberAttributes.Final;
            if (Scope.ToLower().IndexOf("private") > -1)
                ma |= MemberAttributes.Private;
            if (Scope.ToLower().IndexOf("public") > -1)
                ma |= MemberAttributes.Public;
            if (Scope.ToLower().IndexOf("static") > -1)
                ma |= MemberAttributes.Static;
            if (Scope.ToLower().IndexOf("overloaded") > -1)
                ma |= MemberAttributes.Overloaded;
            if (Scope.ToLower().IndexOf("override") > -1)
                ma |= MemberAttributes.Override;
            if (Scope.ToLower().IndexOf("new") > -1)
                ma |= MemberAttributes.New;
            if (Scope.ToLower().IndexOf("assembly") > -1)
                ma |= MemberAttributes.Assembly;

            return ma;
        }
        #endregion

        #region Public Methods
        //***************************************************************************
        // Public Methods
        // 
        /// <summary>
        /// Adds a new class to this AosDynaCode object.
        /// </summary>
        /// <param name="newClass">An initialized AosDynaClass object.</param>
        /// <returns>A bool value indicating success or failure.</returns>
        public void AddClass(DynaClass newClass)
        {
            nsMain.Types.Add(newClass.DynamicClass);
        }
        /// <summary>
        /// Adds a new namespace import (using) to this AosDynaCode object.
        /// </summary>
        /// <param name="NamespaceImport">A string value indicating the namespace import to add.</param>
        public void AddInclude(string NamespaceImport)
        {
            // First, check to make sure the namespace hasn't already been added to the class.
            bool exists = false;
            CodeNamespaceImportCollection nsic = nsMain.Imports;
            foreach (CodeNamespaceImport nsi in nsic)
                if (nsi.Namespace == NamespaceImport)
                    exists = true;

            // If it wasn't found, add it.
            if (!exists)
                nsMain.Imports.Add(new CodeNamespaceImport(NamespaceImport));
        }
        /// <summary>
        /// Removes an existing namespace import (using) from this AosDynaCode object.
        /// </summary>
        /// <param name="NamespaceImport">A string value containing the namespace import to remove.</param>
        public void RemoveInclude(string NamespaceImport)
        {
            CodeNamespaceImportCollection nsic = nsMain.Imports;
            nsMain.Imports.Clear();
            foreach (CodeNamespaceImport nsi in nsic)
                if (nsi.Namespace != NamespaceImport)
                    nsMain.Imports.Add(nsi);
        }
        /// <summary>
        /// Compiles the code within this object into the selected code format and saves it to the given file name.
        /// </summary>
        /// <returns>A FileInfo object set to point to the source file created.</returns>
        public FileInfo GenerateCode(string FileName)
        {
            // First, we're going to set the source FileInfo object to the next source file.
            fiSrc = new FileInfo(FileName);

            // Then, we check for an extension on that file and strip it if one was passed.
            #region DEBUG Output
#if DEBUG
            Console.Write(fiSrc.Extension);
#endif
            #endregion
            if (fiSrc.Extension.Length > 0 && fiSrc.Name.Length > fiSrc.Extension.Length)
                FileName = fiSrc.FullName.Substring(0, fiSrc.FullName.Length - fiSrc.Extension.Length);

            // We get the default extension from the provider object.  Some provider types do not supply the
            //   period on the extension, so we have to check for that.
            if (provider.FileExtension[0] == '.')
                FileName = FileName + provider.FileExtension;
            else
                FileName = FileName + "." + provider.FileExtension;

            IndentedTextWriter tw = null;
            try
            {
                // Now we create the text writer object.  We use an 'IndentedTextWriter' here to achieve
                //   more human-readable source code.
                tw = new IndentedTextWriter(new StreamWriter(FileName, false), "   ");

                // We need to reset our FileInfo object in case the filename was changed.
                fiSrc = new FileInfo(FileName);

                // Now we use the provider object to generate the source code.
                #region DEBUG Output
#if DEBUG
                for (int i = 0; i < compileUnit.Namespaces.Count; i++)
                {
                    Console.WriteLine("\nNamespace: {0}\n\nImports:\n", compileUnit.Namespaces[0].Name);
                    for (int t = 0; t < compileUnit.Namespaces[i].Imports.Count; t++)
                    {
                        Console.WriteLine("  using {0}", compileUnit.Namespaces[i].Imports[t].Namespace);
                    }
                    Console.WriteLine("\n\nClasses:\n");
                    for (int t = 0; t < compileUnit.Namespaces[i].Types.Count; t++)
                    {
                        Console.WriteLine("  -={0} {1}=-", compileUnit.Namespaces[i].Types[t].Attributes.ToString(), compileUnit.Namespaces[i].Types[t].Name);
                        for (int x = 0; x < compileUnit.Namespaces[i].Types[t].Members.Count; x++)
                        {
                            Console.WriteLine("      {0} {1}(-{2}-)", compileUnit.Namespaces[i].Types[t].Members[x].Attributes.ToString(), compileUnit.Namespaces[i].Types[t].Members[x].Name, compileUnit.Namespaces[i].Types[t].Members[x].LinePragma);
                            Console.WriteLine(compileUnit.Namespaces[i].Types[t].Members[x].ToString());
                            for (int j = 0; j < compileUnit.Namespaces[i].Types[t].Members[x].Comments.Count; j++)
                                Console.WriteLine(compileUnit.Namespaces[i].Types[t].Members[x].Comments[j].Comment.Text);
                        }
                    }
                }
#endif
                #endregion
                provider.GenerateCodeFromCompileUnit(compileUnit, tw, new CodeGeneratorOptions());
            }
            catch
            { throw; }
            finally
            {
                // Can't forget to flush and close the output file.  Otherwise, any other functions that
                //   attempt to access it will cause an IO exception.
                if (tw != null)
                {
                    tw.Flush();
                    tw.Close();
                }
            }

            // Return the FileInfo object configured for the output file.
            return fiSrc;
        }
        /// <summary>
        /// Compiles the code within this object into an exe assembly or class library and saves it to the given file name.
        /// </summary>
        /// <param name="provider">An object of type CodeDomProvider that can be used to compile the source code file into an assembly.</param>
        /// <param name="srcFile">The name of the source code file to compile.</param>
        /// <param name="exeFile">The name of the output assembly.</param>
        /// <returns>A CompilerResults object indicating the results of the compile operation.</returns>
        public CompilerResults CompileCode(string exeFile)
        {
            CompilerResults cr = CompileCode(fiSrc.FullName, exeFile, provider, true, false);
            // Set the FileInfo object to point to the compiled EXE file.
            fiExe = new FileInfo(cr.PathToAssembly);
            return cr;
        }
        /// <summary>
        /// Compiles the code with this object into an exe assembly or class library and saves it to the given file name.
        /// </summary>
        /// <param name="exeFile">A string value indicating the output file to generate to the assembly file to.</param>
        /// <param name="createExe">A bool value indicating whether the CodeDOM should create an exe assembly or a class library.</param>
        /// <returns>A CompilerResults object indicating the results of the compile operation.</returns>
        public CompilerResults CompileCode(string exeFile, bool createExe)
        {
            CompilerResults cr = CompileCode(fiSrc.FullName, exeFile, provider, createExe, false);
            // Set the FileInfo object to point to the compiled EXE file.
            fiExe = new FileInfo(cr.PathToAssembly);
            return cr;
        }
        /// <summary>
        /// Compiles the gcode with this object into an exe assembly or class library and saves it to the given file name.
        /// </summary>
        /// <param name="exeFile">A string value indicating the output file to generate to the assembly file to.</param>
        /// <param name="createExe">A bool value indicating whether the CodeDOM should create an exe assembly or a class library.</param>
        /// <param name="includeDebugInfo">A bool value indicating whether debug information should be compiled into the output code.</param>
        /// <returns>A CompilerResults object indicating the results of the compile operation.</returns>
        public CompilerResults CompileCode(string exeFile, bool createExe, bool includeDebugInfo)
        {
            CompilerResults cr = CompileCode(fiSrc.FullName, exeFile, provider, createExe, false);
            // Set the FileInfo object to point to the compiled EXE file.
            fiExe = new FileInfo(cr.PathToAssembly);
            return cr;
        }
        #endregion
    }
}
