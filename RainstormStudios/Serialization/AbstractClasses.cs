using System;
using System.Runtime.Serialization;
using System.Collections.Generic;
using System.Security.Permissions;
using System.Linq;
using System.Text;

namespace RainstormStudios.Serialization
{
    public abstract class SerializableItem : ISerializable, ISerializableItem
    {
        #region Declarations
        //***************************************************************************
        // Private Fields
        // 
        protected readonly static System.Reflection.BindingFlags
            ReflectionGetBindingFlags = System.Reflection.BindingFlags.GetProperty | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public;
        protected readonly static System.Reflection.BindingFlags
            ReflectionSetBindingFlags = System.Reflection.BindingFlags.SetProperty | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic;
        //***************************************************************************
        // Public Fields
        // 
        [SerializeProperty()]
        public string
            CollectionKey { get; protected set; }
        [SerializeProperty()]
        public bool
            IsNew { get; protected set; }
        [SerializeProperty()]
        public bool
            IsEdited { get; protected set; }
        [SerializeProperty()]
        public bool
            IsDeleted { get; protected set; }
        #endregion

        #region Properties
        //***************************************************************************
        // Private Properties
        // 
        protected abstract string SerializationElementName { get; }
        #endregion

        #region Public Methods
        //***************************************************************************
        // Public Methods
        // 
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue(SerializationElementName, this.GetSerialized());
        }
        public virtual string GetSerialized()
        {
            // OK.  Brace yourself....

            // First, we're going to get all public, non-static properties for the current Type.
            System.Reflection.PropertyInfo[] props = this.GetType().GetProperties(ReflectionGetBindingFlags);

            // Create a string builder to store our serialized output.
            System.Text.StringBuilder sb = new System.Text.StringBuilder();

            // Loop through all the found properties.
            for (int i = 0; i < props.Length; i++)
            {
                // Make sure we didn't grab something generated by .NET or that we don't have permission to access.
                if (props[i].IsSpecialName || !props[i].CanRead)
                    continue;

                // TODO:: Use the property attributes to determine if we should serialize
                //   the value, and determine if it's a property that should be set at
                //   the end, or a "parent" value.  The SerializePropertyAttribute
                //   class has already been created for this purpose, but needs to
                //   be expanded on to complete the "settings".

                // Get the property name and its value.
                string propName = props[i].Name;
                object propValue = props[i].GetValue(this, null);

                // Some objects have a "Parent" that we don't want to try and serialize, or
                //   we'll end up with some nasty recursion going on.
                if (propName.ToLower() == "parent")
                    // The deserialize method will look for properties called parent, and
                    //   automatically set them, so we just want "something" to get set.
                    propValue = "this";

                // If the value is NULL, there's not really anything to do, so skip this one.
                if (propValue == null)
                    continue;

                // This is where we decide *how* we're going to serialize the property's value.
                string propValueSerialized = string.Empty;
                if (propValue is ISerializableCollection)
                    // It's possible for epSerializableItem objects to have SerializableCollection children,
                    //   so we need to cast the property value and call the "SerializeCollection" method.
                    propValueSerialized = Hex.ToHex(System.Text.Encoding.UTF8.GetBytes((propValue as ISerializableCollection).SerializeCollection()));

                else if (propValue is ISerializableItem)
                    // I don't think this will ever happen, but we might as well handle it.
                    propValueSerialized = Hex.ToHex(System.Text.Encoding.UTF8.GetBytes((propValue as ISerializableItem).GetSerialized()));

                else if (props[i].PropertyType.Name.ToLower() == "string")
                    // Strings get converted to a byte array, and then stored as a hexidecimal string.
                    //   This prevents any characters in the string from interfering with the serialization formatting.
                    // I know I could have used Base64String for this, but that would result in characters like "=" screwing
                    //   with the serialization.  My way results in just a stream of numbers.
                    propValueSerialized = Hex.ToHex(System.Text.Encoding.UTF8.GetBytes(propValue.ToString()));

                else
                    // Everything else (Int32, Boolean, etc) just stores with their ToString() value.
                    propValueSerialized = propValue.ToString();

                // If the resulting string output is blank, skip it.  I don't want to serialize anything I don't have to.
                if (string.IsNullOrWhiteSpace(propValueSerialized))
                    continue;

                // If this isn't the first entry, append a comma first.
                if (i > 0)
                    sb.Append(",");

                // Now, we just append the property name and its serialized value to the StringBuilder.
                sb.AppendFormat("{0}:{1}", propName, propValueSerialized);
            }
            return sb.ToString();
        }
        public void SetRefKey(string key)
        {
            this.CollectionKey = key;
        }
        public void Delete()
        {
            this.IsDeleted = true;
            this.IsEdited = true;
        }
        public void UnDelete()
        {
            this.IsDeleted = false;
        }
        //***************************************************************************
        // Static Methods
        // 
        /// <summary>
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="itemData"></param>
        /// <returns></returns>
        public static T FromSerializedData<T>(string itemData)
            where T : SerializableItem, new()
        {
            // Did you read the "GetSerialized" method comments?  This is worse. Hold onto your butts...

            // Create a new instance of whatever SerializableItem class "T" is.
            T newItem = new T();

            // Get the Type reference for "T".  We'll use it in a minute.
            Type classType = typeof(T);

            // Start splitting the data.  Each distint set of values are seperated by a comma.
            string[] vals = itemData.Split(',');

            // We want to set these three values at the very end, to make sure they don't get altered by mistake.
            bool isNew = false,
                isEdit = false,
                isDel = false;

            // Loop through the pieces.
            for (int i = 0; i < vals.Length; i++)
            {
                // The key/value pairs of data are seperated by a colon.
                string[] pcs = vals[i].Split(':');
                if (pcs.Length != 2)
                    throw new SerializationException("Unexpected serialization data format.");

                // Check for one of our three specially-handled values.
                if (pcs[0] == "IsEdited")
                { isEdit = bool.Parse(pcs[1]); continue; }
                else if (pcs[0] == "IsNew")
                { isNew = bool.Parse(pcs[1]); continue; }
                else if (pcs[0] == "IsDeleted")
                { isDel = bool.Parse(pcs[1]); continue; }

                // Now, we're going to look for a property with the same name as our key.
                System.Reflection.PropertyInfo prop = classType.GetProperty(pcs[0], ReflectionSetBindingFlags);
                if (prop == null)
                    throw new Exception("Unable to location class member reference in serialized data.");

                // Now, we get to determine exactly how we're going to deserialize the data.
                object setValue = null;
                try
                {
                    if (prop.Name.ToLower() == "parent")
                    {
                        setValue = newItem;
                    }
                    else if (prop.PropertyType.IsAssignableFrom(typeof(SerializableItem)))
                    {
                        System.Reflection.MethodInfo getFromSerializedMethod = prop.PropertyType.GetMethod("FromSerializedData"
                                                                                    , System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.FlattenHierarchy
                                                                                    , null
                                                                                    , new Type[] { typeof(System.String) }
                                                                                    , null);

                        if (getFromSerializedMethod == null)
                            throw new Exception("Unable to determine method to get new item from serialized data.");

                        // This takes the method we found a few lines up, and constructs a generic call with the property's
                        //   data type attached.  This is the MethodInfo we'll actually invoke to call the method.
                        System.Reflection.MethodInfo genericMethodCall = getFromSerializedMethod.MakeGenericMethod(prop.PropertyType);

                        // This should call this same method for the Type of the specified property.
                        setValue = genericMethodCall.Invoke(null, new object[] { pcs[1] });
                    }
                    else if (prop.PropertyType.IsAssignableFrom(typeof(SerializableCollection<>)))
                    {
                        // This is a serialized collection.  We need to create a new instance of the type and call its "DeserializeCollection" method.
                        var col = Activator.CreateInstance(prop.PropertyType);
                        (col as ISerializableCollection).DeserializeCollection(pcs[1]);
                        setValue = col;
                    }
                    else
                    {
                        switch (prop.PropertyType.Name.ToLower())
                        {
                            case "int32":
                                setValue = int.Parse(pcs[1]);
                                break;
                            case "boolean":
                                setValue = bool.Parse(pcs[1]);
                                break;
                            case "double":
                                setValue = double.Parse(pcs[1]);
                                break;
                            case "decimal":
                                setValue = decimal.Parse(pcs[1]);
                                break;
                            case "string":
                                // For string values, we stored a hexidecimal string of their UTF8 encoding.
                                setValue = System.Text.Encoding.UTF8.GetString(Hex.GetBytes(pcs[1]));
                                break;
                            default:
                                throw new Exception("Unhandled data type: " + prop.PropertyType.Name);
                        }
                    }
                }
                catch (Exception ex)
                { throw new Exception("Unable to convert serialized value to property's data type.", ex); }

                prop.SetValue(newItem, setValue, null);
            }

            newItem.IsEdited = isEdit;
            newItem.IsNew = isNew;
            newItem.IsDeleted = isDel;
            return newItem;
        }
        #endregion
    }
    public abstract class SerializableCollection<T> : Collections.ObjectCollectionBase<T>, ISerializable, ISerializableCollection
        where T : SerializableItem, ISerializable
    {
        #region Declarations
        //***************************************************************************
        // Private Fields
        // 
        protected readonly static System.Reflection.BindingFlags
            ReflectionGetBindingFlags = System.Reflection.BindingFlags.GetProperty | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public;
        protected readonly static System.Reflection.BindingFlags
            ReflectionSetBindingFlags = System.Reflection.BindingFlags.SetProperty | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic;
        #endregion

        #region Properties
        //***************************************************************************
        // Private Properties
        // 
        protected abstract string SerializationElementName { get; }
        #endregion

        #region Public Methods
        //***************************************************************************
        // Public Methods
        // 
        [System.Security.Permissions.SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue(SerializationElementName, this.SerializeCollection());
        }
        public string SerializeCollection()
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder();

            IFormatter bFmt = new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter();
            for (int i = 0; i < this.Count; i++)
            {
                using (System.IO.MemoryStream ms = new System.IO.MemoryStream())
                {
                    bFmt.Serialize(ms, this[i]);
                    byte[] bits = ms.ToArray();
                    if (i > 0)
                        sb.Append("|");
                    sb.AppendFormat("{0}={1}", this.GetKey(i), Hex.ToHex(bits));
                }
            }
            return sb.ToString();
        }
        public void DeserializeCollection(string serializedItems)
        {
            string[] items = serializedItems.Split('|');
            for (int i = 0; i < items.Length; i++)
            {
                string[] keyItem = items[i].Split('=');
                if (keyItem.Length < 1)
                    throw new SerializationException("Unexpected serialization data format.");

                string colKey = keyItem[0];
                string itemData = System.Text.Encoding.UTF8.GetString(Hex.GetBytes(keyItem[1]));

                Type tType = typeof(T);
                System.Reflection.MethodInfo getFromSerializedMethod = tType.GetMethod("FromSerializedData"
                                                                            , System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.FlattenHierarchy
                                                                            , null
                                                                            , new Type[] { typeof(System.String) }
                                                                            , null);
                if (getFromSerializedMethod == null)
                    throw new Exception("Unable to determine method to get new item from serialized data.");

                // This takes the method we found a few lines up, and constructs a generic call with the "T"
                //   data type attached.  This is the MethodInfo we'll actually invoke to call the method.
                System.Reflection.MethodInfo genericMethodCall = getFromSerializedMethod.MakeGenericMethod(tType);

                // This should call this same method for the Type of the specified property.
                T qa = (T)genericMethodCall.Invoke(null, new object[] { itemData });

                this.Add(qa, colKey);
            }
        }
        #endregion
    }
}
